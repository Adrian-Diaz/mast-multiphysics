diff --git a/contrib/netcdf/4.3.1/libsrc4/nc4internal.c b/contrib/netcdf/4.3.1/libsrc4/nc4internal.c
index dfd728a..d4c1a41 100644
--- a/contrib/netcdf/4.3.1/libsrc4/nc4internal.c
+++ b/contrib/netcdf/4.3.1/libsrc4/nc4internal.c
@@ -390,7 +390,7 @@ nc4_rec_find_hdf_type(NC_GRP_INFO_T *start_grp, hid_t target_hdf_typeid)
 
 /* Recursively hunt for a netCDF type id. */
 NC_TYPE_INFO_T *
-nc4_rec_find_nc_type(NC_GRP_INFO_T *start_grp, nc_type target_nc_typeid)
+nc4_rec_find_nc_type(NC_GRP_INFO_T *start_grp, hid_t target_nc_typeid)
 {
    NC_GRP_INFO_T *g;
    NC_TYPE_INFO_T *type, *res;
diff --git a/include/mesh/exodusII_io.h b/include/mesh/exodusII_io.h
index a60d8de..fae2e3e 100644
--- a/include/mesh/exodusII_io.h
+++ b/include/mesh/exodusII_io.h
@@ -75,7 +75,8 @@ public:
    * Works in 3D for \p TET4s, \p TET10s, \p HEX8s, and \p HEX27s.
    */
   virtual void read (const std::string & name) libmesh_override;
-
+  virtual void read_parallel (const std::string& base_filename);
+    
   /**
    * This method implements writing a mesh to a specified file.
    */
diff --git a/include/solvers/eigen_solver.h b/include/solvers/eigen_solver.h
index dc378b3..f1d2b8e 100644
--- a/include/solvers/eigen_solver.h
+++ b/include/solvers/eigen_solver.h
@@ -200,7 +200,8 @@ public:
    * and copies the \ ith eigen vector to the solution vector.
    */
   virtual std::pair<Real, Real> get_eigenpair (dof_id_type i,
-                                               NumericVector<T> & solution) = 0;
+                                               NumericVector<T> &eig_vec,
+                                               NumericVector<T> *eig_vec_im = libmesh_nullptr) = 0;
 
   /**
    * Returns the \p ith eigenvalue (real and imaginary part).
diff --git a/include/solvers/slepc_eigen_solver.h b/include/solvers/slepc_eigen_solver.h
index 85d69b1..b35bcb1 100644
--- a/include/solvers/slepc_eigen_solver.h
+++ b/include/solvers/slepc_eigen_solver.h
@@ -185,7 +185,8 @@ public:
    */
   virtual std::pair<Real, Real>
   get_eigenpair (dof_id_type i,
-                 NumericVector<T> & solution_in) libmesh_override;
+                 NumericVector<T> &eig_vec,
+                 NumericVector<T> *eig_vec_im = libmesh_nullptr) libmesh_override;
 
   /**
    * Same as above, but does not copy the eigenvector.
diff --git a/include/systems/implicit_system.h b/include/systems/implicit_system.h
index 1e1f759..251f7a8 100644
--- a/include/systems/implicit_system.h
+++ b/include/systems/implicit_system.h
@@ -153,6 +153,33 @@ public:
    * @e Can be overloaded in derived classes.
    */
   virtual void assemble_residual_derivatives (const ParameterVector & parameters) libmesh_override;
+    
+    /**
+     * Residual parameter derivative function.
+     *
+     * Uses finite differences by default.
+     *
+     * This will assemble the sensitivity rhs vectors to hold
+     * -(partial R / partial p_i), for the \par i ^th parameter in \par v.
+     */
+  virtual void assemble_residual_derivative (const ParameterVector& parameters,
+                                             const unsigned int p,
+                                             NumericVector<Number>& sensitivity_rhs) libmesh_override;
+
+
+    /*!
+     * Solves for the derivative of each of the system's quantities of
+     * interest q in \p qoi[qoi_indices] with respect to \p j ^th parameter in
+     * \p parameters, placing the result for qoi \p i into
+     * \p partialq_partialp[i][j].
+     *
+     * First checks if the user provided assembly objects can provide this data,
+     * otherwise, uses finite differences.
+     */
+    virtual void assemble_qoi_parameter_partial_derivative(const QoISet&          qoi_indices,
+                                                           const ParameterVector& parameters,
+                                                           const unsigned int j,
+                                                           std::vector<Number>& partialq_partialp) libmesh_override;
 
   /**
    * Assembles & solves the linear system(s) (dR/du)*u_p = -dR/dp, for
diff --git a/include/systems/system.h b/include/systems/system.h
index 8734b90..38b49d2 100644
--- a/include/systems/system.h
+++ b/include/systems/system.h
@@ -134,6 +134,35 @@ public:
   };
 
 
+    /**
+     * Abstract base class to be used for assembly of sensitivity
+     * data. A user class derived from this class may be used to
+     * assemble the sensitivity of system by attaching an object
+     * with the method \p attach_sensitivity_assemble_object.
+     */
+    class SensitivityAssembly
+    {
+    public:
+        /**
+         * Destructor.  Virtual because we will have virtual functions.
+         */
+        virtual ~SensitivityAssembly () {}
+        
+        /**
+         * Assembly function.  This function will be called
+         * to assemble the sensitivity of system residual prior to a solve and must
+         * be provided by the user in a derived class. The method provides dR/dp_i
+         * for \par i ^th parameter in the vector \par parameters.
+         *
+         * If the routine is not able to provide sensitivity for this parameter,
+         * then it should return false, and the system will attempt to use
+         * finite differencing.
+         */
+        virtual bool sensitivity_assemble (const ParameterVector& parameters,
+                                           const unsigned int i,
+                                           NumericVector<Number>& sensitivity_rhs) = 0;
+    };
+    
 
   /**
    * Abstract base class to be used for sysem constraints.
@@ -207,6 +236,37 @@ public:
                                  bool apply_constraints) = 0;
   };
 
+    
+    
+    /**
+     * Abstract base class to be used for parameter sensitivities of quantities
+     * of interest, partial q/ partial p. A user class derived from
+     * this class may be used to compute quantities of interest by attaching
+     * an object with the method \p attach_QOI_parameter_sensitivity_object.
+     */
+    class QOIParameterSensitivity
+    {
+    public:
+        /**
+         * Destructor.  Virtual because we will have virtual functions.
+         */
+            virtual ~QOIParameterSensitivity () {}
+        
+        /**
+         * Quantitiy of interest derivative function. This function will
+         * be called to compute derivatived of quantities of interest and
+         * must be provided by the user in a derived class.
+         *
+         * Return true if the method provides sensitivity for the specified parameter,
+         * otherwise, return false and the system will use finite differencing.
+         */
+        virtual bool qoi_parameter_sensitivity (const QoISet& qoi_indices,
+                                                const ParameterVector& parameters,
+                                                const unsigned int p,
+                                                std::vector<Number>& partialq_partialp) = 0;
+    };
+    
+
 
 
   /**
@@ -294,8 +354,25 @@ public:
    * This method is only implemented in some derived classes.
    */
   virtual void assemble_residual_derivatives (const ParameterVector & parameters);
+  virtual void assemble_residual_derivative (const ParameterVector& parameters,
+                                             const unsigned int p,
+                                             NumericVector<Number>& sensitivity_rhs);
+
+    /*!
+     * Solves for the derivative of each of the system's quantities of
+     * interest q in \p qoi[qoi_indices] with respect to \p j ^th parameter in
+     * \p parameters, placing the result for qoi \p i into
+     * \p partialq_partialp[i][j].
+     *
+     * First checks if the user provided assembly objects can provide this data,
+     * otherwise, uses finite differences.
+     */
+    virtual void assemble_qoi_parameter_partial_derivative(const QoISet&          qoi_indices,
+                                                           const ParameterVector& parameters,
+                                                           const unsigned int j,
+                                                           std::vector<Number>& partialq_partialp);
 
-  /**
+    /**
    * After calling this method, any solve will be restricted to the
    * given subdomain.  To disable this mode, call this method with \p
    * subset being a \p NULL pointer.
@@ -1351,9 +1428,39 @@ public:
    */
   void attach_assemble_object (Assembly & assemble);
 
-  /**
-   * Register a user function for imposing constraints.
-   */
+    /**
+     * clears the user specified function/object for assembling the system
+     * matrix and RHS.
+     */
+    void reset_assembly();
+    
+    /**
+     * Register a user function to use in assembling the system
+     * RHS sensitivity. If the routine is unable to provide sensitivity for this
+     * parameter, then it should return false.
+     */
+    void attach_sensitivity_assemble_function (bool fptr(EquationSystems& es,
+                                                         const std::string& name,
+                                                         const ParameterVector& parameters,
+                                                         const unsigned int i,
+                                                         NumericVector<Number>& sensitivity_rhs));
+        
+    /**
+     * Register a user object to use in assembling the system
+     * RHS sensitivity.
+     */
+        void attach_sensitivity_assemble_object (SensitivityAssembly& assemble);
+        
+    /**
+     * clears the user specified function/object for assembling the system
+     * RHS sensitivity.
+     */
+        void reset_sensitivity_assembly ();
+        
+     
+    /**
+     * Register a user function for imposing constraints.
+     */
   void attach_constraint_function (void fptr(EquationSystems & es,
                                              const std::string & name));
 
@@ -1376,6 +1483,13 @@ public:
    */
   void attach_QOI_object (QOI & qoi);
 
+    
+    /**
+     * Removes association with a QOI assembly object or function
+     */
+    void reset_QOI ();
+    
+    
   /**
    * Register a user function for evaluating derivatives of a quantity
    * of interest with respect to test functions, whose values should
@@ -1394,6 +1508,39 @@ public:
    */
   void attach_QOI_derivative_object (QOIDerivative & qoi_derivative);
 
+
+    /**
+     * Removes association with a QOI derivative object or function
+     */
+    void reset_QOI_derivative ();
+    
+    
+    /**
+     * Register a user function for evaluating partial derivatives of a quantity
+     * of interest with respect to specified parameter
+     */
+    void attach_QOI_parameter_sensitivity (bool fptr(EquationSystems& es,
+                                                     const std::string& name,
+                                                     const QoISet& qoi_indices,
+                                                     const ParameterVector& parameters,
+                                                     const unsigned int p,
+                                                     std::vector<Number>& partialq_partialp));
+    
+    /**
+     * Register a user object for evaluating derivatives of a quantity
+     * of interest with respect to test functions, whose values should
+     * be placed in \p System::rhs
+     */
+    void attach_QOI_parameter_sensitivity_object (QOIParameterSensitivity& qoi_sensitivity);
+    
+    
+    /**
+     * Removes association with a QOI parameteric sensitivity object or function
+     */
+    void reset_QOI_parameter_sensitivity ();
+
+
+    
   /**
    * Calls user's attached initialization function, or is overloaded by
    * the user in derived classes.
@@ -1406,6 +1553,15 @@ public:
    */
   virtual void user_assembly ();
 
+    /**
+     *  returs true if a user provided function or object is able to provide
+     *  the sensitivity data for the \par i ^th parameter in the vector
+     *  \par parameters.
+     */
+    bool user_sensitivity_assembly(const ParameterVector& parameters,
+                                   const unsigned int i,
+                                   NumericVector<Number>& sensitivity_rhs);
+    
   /**
    * Calls user's attached constraint function, or is overloaded by
    * the user in derived classes.
@@ -1425,8 +1581,17 @@ public:
   virtual void user_QOI_derivative (const QoISet & qoi_indices = QoISet(),
                                     bool include_liftfunc = true,
                                     bool apply_constraints = true);
-
-  /**
+    
+    /**
+     * Calls user's attached quantity of interest derivative function,
+     * or is overloaded by the user in derived classes.
+     */
+    virtual bool user_QOI_parameter_sensitivity (const QoISet& qoi_indices,
+                                                 const ParameterVector& parameters,
+                                                 const unsigned int p,
+                                                 std::vector<Number>& partialq_partialp);
+    
+    /**
    * Re-update the local values when the mesh has changed.
    * This method takes the data updated by \p update() and
    * makes it up-to-date on the current mesh.
@@ -1803,8 +1968,25 @@ private:
    */
   Assembly * _assemble_system_object;
 
-  /**
-   * Function to impose constraints.
+
+    /**
+     * Function that assembles the sensitivity of system.
+     */
+    bool (* _sensitivity_assemble_system_function) (EquationSystems& es,
+                                                    const std::string& name,
+                                                    const ParameterVector& parameter,
+                                                    const unsigned int i,
+                                                    NumericVector<Number>& sensitivity_rhs);
+    
+    /**
+     * Object that assembles the sensitivity of system.
+     */
+    SensitivityAssembly * _sensitivity_assemble_system_object;
+    
+    
+    
+    /**
+     * Function to impose constraints.
    */
   void (* _constrain_system_function) (EquationSystems & es,
                                        const std::string & name);
@@ -1835,12 +2017,28 @@ private:
                                               bool include_liftfunc,
                                               bool apply_constraints);
 
+    /**
+     * Function to evaluate quantity of interest partial derivative wrt parameter
+     */
+    bool (* _qoi_evaluate_parameter_sensitivity_function) (EquationSystems& es,
+                                                           const std::string& name,
+                                                           const QoISet& qoi_indices,
+                                                           const ParameterVector& parameters,
+                                                           const unsigned int p,
+                                                           std::vector<Number>& partialq_partialp);
+
   /**
    * Object to compute derivatives of quantities of interest.
    */
   QOIDerivative * _qoi_evaluate_derivative_object;
 
-  /**
+ /**
+  * Object to compute partial sensitivity of quantities of interest wrt parameter.
+  */
+  QOIParameterSensitivity *_qoi_evaluate_parameter_sensitivity_object;
+
+    
+ /**
    * Data structure describing the relationship between
    * nodes, variables, etc... and degrees of freedom.
    */
@@ -2233,8 +2431,26 @@ void System::assemble_residual_derivatives (const ParameterVector &)
 {
   libmesh_not_implemented();
 }
+    
+inline
+void System::assemble_qoi_parameter_partial_derivative(const QoISet& ,
+                                                       const ParameterVector& ,
+                                                       const unsigned int ,
+                                                       std::vector<Number>& )
+{
+    libmesh_not_implemented();
+}
 
 inline
+void System::assemble_residual_derivative (const ParameterVector&,
+                                           const unsigned int ,
+                                           NumericVector<Number>& )
+{
+    libmesh_not_implemented();
+}
+    
+    
+inline
 void System::disable_cache () { assemble_before_solve = true; }
 
 inline
diff --git a/src/base/dof_map_constraints.C b/src/base/dof_map_constraints.C
index cc26afd..0331bb1 100644
--- a/src/base/dof_map_constraints.C
+++ b/src/base/dof_map_constraints.C
@@ -2593,7 +2593,7 @@ void DofMap::build_constraint_matrix_and_vector (DenseMatrix<Number> & C,
         {
           // If x = Cy + h and y = Dz + g
           // Then x = (CD)z + (Cg + h)
-          C.vector_mult_add(H, 1, Hnew);
+          C.vector_mult_add(H, (Number)1, Hnew);
 
           C.right_multiply(Cnew);
         }
diff --git a/src/mesh/exodusII_io.C b/src/mesh/exodusII_io.C
index b140078..325ce50 100644
--- a/src/mesh/exodusII_io.C
+++ b/src/mesh/exodusII_io.C
@@ -34,6 +34,10 @@
 #include "libmesh/numeric_vector.h"
 #include "libmesh/exodusII_io_helper.h"
 #include "libmesh/string_to_enum.h"
+#include "libmesh/nemesis_io_helper.h"
+#include "libmesh/parmetis_helper.h"
+#include "libmesh/mesh_communication.h"
+#include "libmesh/parallel_mesh.h"
 
 namespace libMesh
 {
@@ -389,6 +393,477 @@ void ExodusII_IO::read (const std::string & fname)
 }
 
 
+    
+void ExodusII_IO::read_parallel (const std::string& base_filename)
+{
+      // On one processor, Nemesis and ExodusII should be equivalent, so
+      // let's cowardly defer to that implementation...
+      if (this->n_processors() == 1)
+          {
+                // We can do this in one line but if the verbose flag was set in this
+                // object, it will no longer be set... thus no extra print-outs for serial runs.
+                // ExodusII_IO(this->mesh()).read (base_filename); // ambiguous when Nemesis_IO is multiply-inherited
+        
+                this->read (base_filename);
+                return;
+              }
+
+      START_LOG ("read()","Exodus_IO");
+
+
+      libMesh::out << "getting into read" << std::endl;
+
+      // This function must be run on all processors at once
+      parallel_object_only();
+
+      // Open the Exodus file
+      this->exio_helper->open(base_filename.c_str(), true); // just to avoid error from within this class
+      ExodusII_IO_Helper ex_io_helper(this->comm(), true, false);
+      ex_io_helper.open(base_filename.c_str(), true);
+
+      // Get a reference to the mesh.  We need to be specific
+      // since Nemesis_IO is multiply-inherited
+      // MeshBase& mesh = this->mesh();
+      MeshBase& mesh = MeshInput<MeshBase>::mesh();
+
+      // Local information: Read the following information from the standard Exodus header
+      //  title[0]
+      //  num_dim
+      //  num_nodes
+      //  num_elem
+      //  num_elem_blk
+      //  num_node_sets
+      //  num_side_sets
+      ex_io_helper.read_header();
+      ex_io_helper.print_header();
+
+      libMesh::out << "after header" << std::endl;
+
+      ex_io_helper.read_block_info();
+
+      exII::ex_get_elem_block(ex_io_helper.ex_id,
+                                                             ex_io_helper.block_ids[0],
+                                                             &ex_io_helper.elem_type[0],
+                                                             &ex_io_helper.num_elem_this_blk,
+                                                             &ex_io_helper.num_nodes_per_elem,
+                                                             &ex_io_helper.num_attr);
+
+      libMesh::out << "after read block info" << std::endl;
+
+      //    // Get global information: number of nodes, elems, blocks, nodesets and sidesets
+      //    ex_helper.get_init_global();
+
+      // the approach is to partition the elements based on a space-filling approach.
+      // So, the centroid information of each element is obtained using the nodal information.
+      // First, each processor reads in its chunk of the elements
+
+      // beginning and end of elem_ids on each processor
+      std::vector<int> proc_elems(this->n_processors()+1, 0);
+      int n_remaining_elems = ex_io_helper.num_elem,
+      n_elems_per_proc = ex_io_helper.num_elem / this->n_processors();
+
+      proc_elems[0] = 1; // exodus numbering starts from 1
+      for (unsigned int i=0; i<this->n_processors(); i++)
+          {
+                proc_elems[i+1] = proc_elems[i] + std::min( n_elems_per_proc, n_remaining_elems)+1;
+                n_remaining_elems -= (proc_elems[i+1]-proc_elems[i]);
+              }
+
+      proc_elems[this->n_processors()] += n_remaining_elems; // in case any elements were left unassigned
+
+      unsigned int n_local_elems =
+      proc_elems[this->processor_id()+1] - proc_elems[this->processor_id()];
+      std::vector<char> elem_type(10);
+      int n_elem_in_block=0, n_nodes_per_elem=0, n_attr=0;
+
+      libMesh::out << "Elem range on proc: " << this->processor_id() << "  "
+      << proc_elems[this->processor_id()] << "  " << proc_elems[this->processor_id()+1]
+      << " n elem on proc: " << n_local_elems << std::endl;
+
+      exII::ex_get_elem_block(ex_io_helper.ex_id, ex_io_helper.block_ids[0], &elem_type[0],
+                                                             &n_elem_in_block,
+                                                             &n_nodes_per_elem,
+                                                             &n_attr);
+
+      libMesh::out << "after block elem info" << std::endl;
+
+      std::vector<int> elem_conn(n_local_elems * n_nodes_per_elem, 0);
+      std::vector<double> elem_xyz(n_local_elems*ex_io_helper.num_dim, 0.);
+
+      int err = Nemesis::ne_get_n_elem_conn(ex_io_helper.ex_id, ex_io_helper.block_ids[0], proc_elems[this->processor_id()],
+                                                                                         n_local_elems, &elem_conn[0]);
+
+      libMesh::out << "after elem conn" << std::endl;
+
+      // find the first and last nodes
+      dof_id_type first_node=ex_io_helper.num_nodes, last_node=0;
+      for (dof_id_type i=0; i<elem_conn.size(); i++)
+          {
+                if (first_node > elem_conn[i])
+                      first_node = elem_conn[i];
+                if (last_node < elem_conn[i])
+                      last_node = elem_conn[i];
+              }
+
+      libMesh::out << "Node range on proc: " << this->processor_id() << "  " << first_node << "  " << last_node << std::endl;
+
+      // now read in the detail for each node specified in the connectivity list for each element, and calculate
+      // the centroid information
+      // hopefully the size of these vectors will not be too huge
+      std::vector<Real> node_x(last_node-first_node+1, 0.),
+      node_y(last_node-first_node+1, 0.), node_z(last_node-first_node+1, 0.);
+      err = Nemesis::ne_get_n_coord(ex_io_helper.ex_id, first_node, last_node-first_node+1,
+                                                                         &node_x[0], &node_y[0], &node_z[0]);
+
+      unsigned int node_pos_in_vector;
+      for (unsigned int i_elem=0; i_elem<n_local_elems; i_elem++)
+          {
+                for (unsigned int i_node=0; i_node<n_nodes_per_elem; i_node++)
+                    {
+                          node_pos_in_vector = elem_conn[i_elem*n_nodes_per_elem+i_node]-first_node;
+                          elem_xyz[i_elem*ex_io_helper.num_dim+0] += node_x[node_pos_in_vector];
+                          elem_xyz[i_elem*ex_io_helper.num_dim+1] += node_y[node_pos_in_vector];
+                          elem_xyz[i_elem*ex_io_helper.num_dim+2] += node_z[node_pos_in_vector];
+                        }
+                elem_xyz[i_elem*ex_io_helper.num_dim+0] /= n_nodes_per_elem;
+                elem_xyz[i_elem*ex_io_helper.num_dim+1] /= n_nodes_per_elem;
+                elem_xyz[i_elem*ex_io_helper.num_dim+2] /= n_nodes_per_elem;
+              }
+
+      // clear unneeded storage
+      node_x.clear(); node_y.clear(); node_z.clear();
+
+      // now call the partitioner
+      std::vector<int> part(n_local_elems, 0);
+      MPI_Comm mpi_comm = this->comm().get();
+
+      libMesh::out << "getting into Parmetis" << std::endl;
+
+      err = Parmetis::ParMETIS_V3_PartGeom(&proc_elems[0], &ex_io_helper.num_dim, &elem_xyz[0],
+                                                                                       &part[0], &mpi_comm);
+
+      libMesh::out << "after Parmetis" << std::endl;
+
+      // clear unneeded storage
+      elem_xyz.clear();
+
+      // now, this partitioning needs to be communicated to the respective processors
+      std::vector<dof_id_type> collected_elems_on_proc, elems_for_comm;
+
+      // add elements from the local processor
+      unsigned int n_elems_for_comm = 0;
+      elems_for_comm.resize(n_local_elems);
+
+      // iterate over the elements locally and create the list of
+      // elements that belong to proc dest
+      for (unsigned int i=0; i<n_local_elems; i++)
+            if (part[i] == this->processor_id())
+                {
+                      elems_for_comm[n_elems_for_comm] = proc_elems[this->processor_id()]+i;
+                      n_elems_for_comm++;
+                    }
+      collected_elems_on_proc.insert(collected_elems_on_proc.end(),
+                                                                           elems_for_comm.begin(),
+                                                                           elems_for_comm.begin()+n_elems_for_comm);
+
+
+      for (processor_id_type pid=0; pid<mesh.n_processors(); pid++) // pid received data from others
+          {
+                if (pid == this->processor_id()) // receive from others
+                    {
+                          std::cout << "***** Receiving for pid: " << pid << std::endl;
+                          for (processor_id_type source=0; source<mesh.n_processors(); source++)
+                                if (source != this->processor_id()) // don't send to self
+                                    {
+                                          elems_for_comm.clear();
+                                          this->comm().receive(source, elems_for_comm);
+                                          std::cout << "Received: " << elems_for_comm.size() << " elems from proc: " << source << std::endl;
+                                          collected_elems_on_proc.insert(collected_elems_on_proc.end(),
+                                                                                                                       elems_for_comm.begin(), elems_for_comm.end());
+                                        }
+                          std::cout << "Total: " << collected_elems_on_proc.size() << " elems on proc: " << pid << std::endl;
+                        }
+                else // send data to pid
+                    {
+                          std::cout << "***** Sending from pid: " << this->processor_id() << std::endl;
+                          elems_for_comm.resize(n_local_elems); // upper limit of the size for this vector
+                
+                          n_elems_for_comm = 0;
+                
+                          // iterate over the elements locally and create the list of
+                          // elements that belong to proc dest
+                          for (unsigned int i=0; i<n_local_elems; i++)
+                                if (part[i] == pid)
+                                    {
+                                          elems_for_comm[n_elems_for_comm] = proc_elems[this->processor_id()]+i;
+                                          n_elems_for_comm++;
+                                        }
+                
+                          std::vector<dof_id_type> elem_send_list;
+                          elem_send_list.insert(elem_send_list.end(),
+                                                                                 elems_for_comm.begin(),
+                                                                                 elems_for_comm.begin()+n_elems_for_comm);
+                
+                          std::cout << "Sending: " << elem_send_list.size() << " elems to proc: " << pid << std::endl;
+                          this->comm().send(pid, elem_send_list);
+                        }
+              }
+
+      // clear the unneeded storage
+      elems_for_comm.clear(); part.clear();
+
+      // find the range of element ids
+      unsigned int first_elem=ex_io_helper.num_elem, last_elem=0;
+      for (std::vector<unsigned int>::const_iterator elem_it=collected_elems_on_proc.begin();
+                       elem_it != collected_elems_on_proc.end(); elem_it++)
+          {
+                if (*elem_it > last_elem)
+                      last_elem = *elem_it;
+                if (*elem_it < first_elem)
+                      first_elem = *elem_it;
+              }
+
+      // now, get the node details for this element range
+      n_local_elems = collected_elems_on_proc.size();
+      elem_conn.resize((last_elem-first_elem+1) * n_nodes_per_elem); // this stores the connectivity for the entire range
+
+      libMesh::out << "Elem range: " << first_elem << "  --  "  << last_elem << "  : with total elems:  " << n_local_elems << std::endl;
+
+
+      libMesh::out << "Reading updated element connectivity " << std::endl;
+
+      err = Nemesis::ne_get_n_elem_conn(ex_io_helper.ex_id, ex_io_helper.block_ids[0], first_elem,
+                                                                                 (last_elem-first_elem+1), &elem_conn[0]);
+
+      libMesh::out << "Done reading updated element connectivity: Preparing node process ids" << std::endl;
+
+      // find the node ownership and the range of node ids on this processor.
+      // If a node lies on multiple processors, then the smallest processor id would take ownership of the node
+
+      std::map<dof_id_type, processor_id_type> node_processor_id_map;
+
+      unsigned int elem_offset, node_offset;
+      for (std::vector<unsigned int>::const_iterator elem_it=collected_elems_on_proc.begin();
+                       elem_it != collected_elems_on_proc.end(); elem_it++)
+          {
+                elem_offset = (*elem_it-first_elem)*n_nodes_per_elem; // offset for connectivity data
+        
+                for (unsigned int j=0; j<n_nodes_per_elem; j++)
+                      // start by identify each node to be on this processor
+                      // this will be changed later
+                      node_processor_id_map[elem_conn[elem_offset+j]] = this->processor_id();
+              }
+
+      // get the first and last node ids from the map
+      first_node = node_processor_id_map.begin()->first;
+      last_node = node_processor_id_map.rbegin()->first;
+
+      libMesh::out << "Done preparing node process ids: communicating IDs to processors" << std::endl;
+
+      // now each processor communicates to the higher rank processors about the ownership
+      for (processor_id_type pid=0; pid<mesh.n_processors(); pid++) // pid sends data to higher ranked processors
+          {
+                //prepare the node vector and send it to higher ranked processors
+                if (pid == this->processor_id())
+                    {
+                          std::vector<dof_id_type> locally_owned_nodes(node_processor_id_map.size());
+                          dof_id_type index=0;
+                          for (std::map<dof_id_type, processor_id_type>::const_iterator map_it=node_processor_id_map.begin();
+                                               map_it != node_processor_id_map.end(); map_it++)
+                              {
+                                    if (map_it->second == pid) // pid == this->processor_id() here
+                                          locally_owned_nodes[index++] = map_it->first;
+                                  }
+                
+                          // send the data to the processor in a vector that is
+                          // sized for the number of locally owned nodes
+                          std::vector<dof_id_type> data_to_send;
+                          data_to_send.insert(data_to_send.end(), locally_owned_nodes.begin(), locally_owned_nodes.end());
+                          locally_owned_nodes.clear();
+                
+                          // send this to all processors of higher rank
+                          std::cout << "Sending nodes to processors: n_nodes = " << data_to_send.size() << " : from pid = " <<  pid << std::endl;
+                          for (processor_id_type dest=pid+1; dest<mesh.n_processors(); dest++)
+                                this->comm().send(dest, data_to_send);
+                        }
+                else if (pid < this->processor_id()) // receive from lower ranked processors
+                    {
+                          // get the remote node ids
+                          std::vector<dof_id_type> remote_nodes;
+                          this->comm().receive(pid, remote_nodes);
+                
+                          libMesh::out << "Received from : " << pid << " by " << this->processor_id() << " n_nodes : " << remote_nodes.size()  << std::endl;
+                
+                          // now iterate over these nodes and set their processor ids
+                          std::map<dof_id_type, processor_id_type>::iterator map_it;
+                          std::map<dof_id_type, processor_id_type>::const_iterator map_end = node_processor_id_map.end();
+                          for (std::vector<dof_id_type>::const_iterator node_it=remote_nodes.begin();
+                                               node_it != remote_nodes.end(); node_it++)
+                              {
+                                    // check if the node also lies on this processor
+                                    map_it = node_processor_id_map.find(*node_it);
+                                    if (map_it != map_end)
+                                          map_it->second = pid;
+                                  }
+                        }
+              }
+
+      libMesh::out << "Node range on proc: " << this->processor_id() << "  " << first_node << "  " << last_node << std::endl;
+
+      // now read in the detail for each node specified in the connectivity list for each element, and calculate
+      // the centroid information
+      // hopefully the size of these vectors will not be too huge
+      node_x.resize(last_node-first_node+1, 0.);
+      node_y.resize(last_node-first_node+1, 0.);
+      node_z.resize(last_node-first_node+1, 0.);
+
+      libMesh::out << "Reading node coordinates " << std::endl;
+
+      err = Nemesis::ne_get_n_coord(ex_io_helper.ex_id, first_node, last_node-first_node+1,
+                                                                         &node_x[0], &node_y[0], &node_z[0]);
+
+      libMesh::out << "Done reading node coordinates: Now adding nodes and elements to mesh " << std::endl;
+
+      // add the nodes and elements
+      ExodusII_IO_Helper::ElementMaps em; //(*exio_helper);     // Instantiate the ElementMaps interface
+      const std::string type_str (ex_io_helper.get_elem_type());
+      const ExodusII_IO_Helper::Conversion conv = em.assign_conversion(type_str);
+      
+      Node* node_ptr;
+      std::map<dof_id_type, processor_id_type>::const_iterator map_it,
+      map_end = node_processor_id_map.end();
+      // Loop over all the elements in this block
+      for (std::vector<unsigned int>::const_iterator elem_it=collected_elems_on_proc.begin();
+                       elem_it != collected_elems_on_proc.end(); elem_it++)
+          {
+                elem_offset = (*elem_it-first_elem)*n_nodes_per_elem; // offset for connectivity data
+                
+                Elem* elem = Elem::build (conv.get_canonical_type()).release(); // create the element
+                elem->processor_id(this->processor_id()); // only add locally
+                elem->set_id(*elem_it); // prescribe the elem id
+                
+                for (unsigned int j=0; j<n_nodes_per_elem; j++)
+                    {
+                          node_ptr = mesh.query_node_ptr(elem_conn[elem_offset+j]);
+                          if (node_ptr == NULL)
+                              {
+                                    node_offset = elem_conn[elem_offset+j] - first_node;
+                                    
+                                    // local map should certainly have this node id
+                                    map_it = node_processor_id_map.find(elem_conn[elem_offset+j]);
+                                    libmesh_assert(map_it != map_end);
+                                    
+                                    // use the node id, add processor id identified earlies
+                                    node_ptr = mesh.add_point(Point(node_x[node_offset],
+                                                                                                                 node_y[node_offset],
+                                                                                                                 node_z[node_offset]),
+                                                                                                     elem_conn[elem_offset+j],
+                                                                                                     map_it->second);
+                                  }
+                          
+                          elem->set_node(j) = node_ptr;
+                        }
+                
+                mesh.add_elem(elem);
+              }
+      
+      // clear unneeded storage
+      collected_elems_on_proc.clear(); elem_conn.clear();
+      node_x.clear(); node_y.clear(); node_z.clear();
+      node_processor_id_map.clear();
+      
+      
+      unsigned int n_side_sets = 0;
+      // Read in sideset information -- this is useful for applying boundary conditions
+      {
+            ex_io_helper.read_sideset_info(); // Get basic information about ALL sidesets
+            int offset=0;
+            for (int i=0; i<ex_io_helper.num_side_sets; i++)
+                {
+                      offset += (i > 0 ? ex_io_helper.num_sides_per_set[i-1] : 0); // Compute new offset
+                      ex_io_helper.read_sideset (i, offset);
+                      
+                      mesh.boundary_info->sideset_name(ex_io_helper.get_side_set_id(i)) =
+                      ex_io_helper.get_side_set_name(i);
+                    }
+            
+            const std::vector<int>& elem_list = ex_io_helper.elem_list;
+            const std::vector<int>& side_list = ex_io_helper.side_list;
+            const std::vector<int>& id_list   = ex_io_helper.id_list;
+            
+            for (unsigned int e=0; e<elem_list.size(); e++)
+                {
+                      // Set any relevant node/edge maps for this element
+                      
+                      Elem * elem = mesh.query_elem(elem_list[e]);
+                      
+                      if (elem != NULL) // proceed only if this processor contains this elemid
+                          {
+                                
+                                const ExodusII_IO_Helper::Conversion conv =
+                                em.assign_conversion(elem->type());
+                                
+                                mesh.boundary_info->add_side (elem_list[e],
+                                                                                                         conv.get_side_map(side_list[e]-1),
+                                                                                                         id_list[e]);
+                                n_side_sets++;
+                              }
+                    }
+          }
+      
+      
+      std::cout << "Done adding side set: on pid: " << this->processor_id() << " : n_side_sets : " << n_side_sets << std::endl;
+      this->comm().sum(n_side_sets);
+      std::cout << "Total side sets: " << n_side_sets << std::endl;
+      
+      // Read nodeset info
+      {
+            ex_io_helper.read_nodeset_info();
+            
+            for (int nodeset=0; nodeset<ex_io_helper.num_node_sets; nodeset++)
+                {
+                      int nodeset_id = ex_io_helper.get_node_set_id(nodeset);
+                      
+                      mesh.boundary_info->nodeset_name(nodeset_id) =
+                      ex_io_helper.get_node_set_name(nodeset);
+                      
+                      ex_io_helper.read_nodeset(nodeset);
+                      
+                      const std::vector<int>& node_list = ex_io_helper.node_list;
+                      
+                      for(unsigned int node=0; node<node_list.size(); node++)
+                          {
+                                Node * node_ptr = mesh.query_node_ptr(node_list[node]);
+                                if (node_ptr != NULL)
+                                      mesh.boundary_info->add_node(node_list[node], nodeset_id);
+                              }
+                    }
+          }
+      
+      
+      
+      libMesh::out << "Done adding elements to mesh: Now preparing for use " << std::endl;
+      
+      err = exII::ex_close(ex_io_helper.ex_id);
+      
+      
+      // For ParallelMesh, it seems that _is_serial is true by default.  A hack to
+      // make the Mesh think it's parallel might be to call:
+      mesh.update_post_partitioning();
+      mesh.delete_remote_elements();
+      
+      // now prepare for use
+      MeshCommunication().gather_neighboring_elements(libmesh_cast_ref<ParallelMesh&>(mesh));
+      
+      libMesh::out << "Done " << std::endl;
+      
+      STOP_LOG ("read()","Exodus_IO");
+      
+      return;
+    }
+
+
+
 
 void ExodusII_IO::verbose (bool set_verbosity)
 {
diff --git a/src/solvers/slepc_eigen_solver.C b/src/solvers/slepc_eigen_solver.C
index 07dc1ad..392946a 100644
--- a/src/solvers/slepc_eigen_solver.C
+++ b/src/solvers/slepc_eigen_solver.C
@@ -655,32 +655,53 @@ void SlepcEigenSolver<T>:: set_slepc_position_of_spectrum()
 
 template <typename T>
 std::pair<Real, Real> SlepcEigenSolver<T>::get_eigenpair(dof_id_type i,
-                                                         NumericVector<T> & solution_in)
+                                                         NumericVector<T> &eig_vec,
+                                                         NumericVector<T> *eig_vec_im)
 {
-  PetscErrorCode ierr=0;
-
-  PetscReal re, im;
+    // make sure that for non-Hermitian problems with real matrices
+    // a vector is provided for imaginary part.
+#ifdef LIBMESH_USE_COMPLEX_NUMBERS
+    libmesh_assert(eig_vec_im == NULL);
+#else
+        if (this->eigen_problem_type() == HEP ||
+                     this->eigen_problem_type() == GHEP)
+                libmesh_assert(eig_vec_im == NULL);
+#endif
 
-  // Make sure the NumericVector passed in is really a PetscVector
-  PetscVector<T> * solution = cast_ptr<PetscVector<T> *>(&solution_in);
+    PetscErrorCode ierr=0;
 
-  // real and imaginary part of the ith eigenvalue.
-  PetscScalar kr, ki;
+    PetscReal re, im;
 
-  solution->close();
+    // Make sure the NumericVector passed in is really a PetscVector
+    PetscVector<T>* v_re = cast_ptr<PetscVector<T>*>(&eig_vec);
+    PetscVector<T>* v_im = NULL;
 
-  ierr = EPSGetEigenpair(_eps, i, &kr, &ki, solution->vec(), PETSC_NULL);
-  LIBMESH_CHKERR(ierr);
+    // real and imaginary part of the ith eigenvalue.
+    PetscScalar kr, ki;
 
+    eig_vec.close();
+    if (eig_vec_im)
+        {
+                eig_vec_im = libmesh_cast_ptr<PetscVector<T>*>(eig_vec_im);
+                eig_vec_im->close();
+        
+                // now get the eigenvector
+                ierr = EPSGetEigenpair(_eps, i, &kr, &ki, v_re->vec(), v_im->vec());
+            }
+    else
+            ierr = EPSGetEigenpair(_eps, i, &kr, &ki, v_re->vec(), PETSC_NULL);
+
+    LIBMESH_CHKERR(ierr);
+    
 #ifdef LIBMESH_USE_COMPLEX_NUMBERS
-  re = PetscRealPart(kr);
-  im = PetscImaginaryPart(kr);
+    re = PetscRealPart(kr);
+    im = PetscImaginaryPart(kr);
 #else
-  re = kr;
-  im = ki;
+        re = kr;
+    im = ki;
 #endif
-
-  return std::make_pair(re, im);
+    
+    return std::make_pair(re, im);
 }
 
 
diff --git a/src/systems/implicit_system.C b/src/systems/implicit_system.C
index 0cd8bcd..78891e3 100644
--- a/src/systems/implicit_system.C
+++ b/src/systems/implicit_system.C
@@ -316,7 +316,12 @@ ImplicitSystem::sensitivity_solve (const ParameterVector & parameters)
       this->matrix->close();
 
       // Reset and build the RHS from the residual derivatives
-      this->assemble_residual_derivatives(parameters);
+      for (unsigned int p=0; p<parameters.size(); p++)
+      {
+          NumericVector<Number> &sensitivity_rhs = this->add_sensitivity_rhs(p);
+          this->assemble_residual_derivative(parameters, p,
+                                             sensitivity_rhs);
+      }
     }
 
   // The sensitivity problem is linear
@@ -686,7 +691,54 @@ void ImplicitSystem::assemble_residual_derivatives(const ParameterVector & param
     }
 }
 
+    
+    
+    
+void ImplicitSystem::assemble_residual_derivative(const ParameterVector & parameters_in,
+                                                  const unsigned int p,
+                                                  NumericVector<Number>& sensitivity_rhs)
 
+{
+    ParameterVector & parameters =
+    const_cast<ParameterVector &>(parameters_in);
+    
+    if (!user_sensitivity_assembly(parameters, p, sensitivity_rhs))
+    {
+        NumericVector<Number> & sensitivity_rhs = this->add_sensitivity_rhs(p);
+        
+        // Approximate -(partial R / partial p) by
+        // (R(p-dp) - R(p+dp)) / (2*dp)
+        
+        Number old_parameter = *parameters[p];
+        
+        const Real delta_p =
+        TOLERANCE * std::max(std::abs(old_parameter), 1e-3);
+        
+        *parameters[p] -= delta_p;
+        
+        //      this->assembly(true, false, true);
+        this->assembly(true, false, false);
+        this->rhs->close();
+        sensitivity_rhs = *this->rhs;
+        
+        *parameters[p] = old_parameter + delta_p;
+        
+        //      this->assembly(true, false, true);
+        this->assembly(true, false, false);
+        this->rhs->close();
+        
+        sensitivity_rhs -= *this->rhs;
+        sensitivity_rhs /= (2*delta_p);
+        sensitivity_rhs.close();
+        
+        *parameters[p] = old_parameter;
+    }
+}
+
+
+    
+    
+    
 
 void ImplicitSystem::adjoint_qoi_parameter_sensitivity (const QoISet & qoi_indices,
                                                         const ParameterVector & parameters_in,
@@ -889,7 +941,51 @@ void ImplicitSystem::forward_qoi_parameter_sensitivity (const QoISet & qoi_indic
 }
 
 
+void ImplicitSystem::assemble_qoi_parameter_partial_derivative(const QoISet&          qoi_indices,
+                                                               const ParameterVector& parameters_in,
+                                                               const unsigned int j,
+                                                               std::vector<Number>& partialq_partialp)
+{
+    // check if the user supplied routine are able to provide this data
+     if (!this->user_QOI_parameter_sensitivity(qoi_indices, parameters_in,
+     j, partialq_partialp))
+     {
+     
+     ParameterVector & parameters =
+     const_cast<ParameterVector &>(parameters_in);
+
+     const unsigned int Nq = libmesh_cast_int<unsigned int>
+     (qoi.size());
+     
+     // We currently get partial derivatives via central differencing
+     const Real delta_p = TOLERANCE;
+     
+     // (partial q / partial p) ~= (q(p+dp)-q(p-dp))/(2*dp)
+     // (partial R / partial p) ~= (rhs(p+dp) - rhs(p-dp))/(2*dp)
+     
+     Number old_parameter = *parameters[j];
+     // Number old_qoi = this->qoi;
+     
+     *parameters[j] = old_parameter - delta_p;
+     this->assemble_qoi(qoi_indices);
+     std::vector<Number> qoi_minus = this->qoi;
+     
+     *parameters[j] = old_parameter + delta_p;
+     this->assemble_qoi(qoi_indices);
+     std::vector<Number>& qoi_plus = this->qoi;
+     
+     for (unsigned int i=0; i != Nq; ++i)
+     if (qoi_indices.has_index(i))
+     partialq_partialp[i] = (qoi_plus[i] - qoi_minus[i]) / (2.*delta_p);
+     
+     // Don't leave the parameter changed
+     *parameters[j] = old_parameter;
+     }
+}
+
 
+    
+    
 void ImplicitSystem::qoi_parameter_hessian_vector_product (const QoISet & qoi_indices,
                                                            const ParameterVector & parameters_in,
                                                            const ParameterVector & vector,
diff --git a/src/systems/system.C b/src/systems/system.C
index 693670f..10a9484 100644
--- a/src/systems/system.C
+++ b/src/systems/system.C
@@ -69,13 +69,17 @@ System::System (EquationSystems & es,
   _init_system_function             (libmesh_nullptr),
   _init_system_object               (libmesh_nullptr),
   _assemble_system_function         (libmesh_nullptr),
+  _sensitivity_assemble_system_function        (libmesh_nullptr),
   _assemble_system_object           (libmesh_nullptr),
+  _sensitivity_assemble_system_object          (libmesh_nullptr),
   _constrain_system_function        (libmesh_nullptr),
   _constrain_system_object          (libmesh_nullptr),
   _qoi_evaluate_function            (libmesh_nullptr),
   _qoi_evaluate_object              (libmesh_nullptr),
   _qoi_evaluate_derivative_function (libmesh_nullptr),
   _qoi_evaluate_derivative_object   (libmesh_nullptr),
+  _qoi_evaluate_parameter_sensitivity_function (nullptr),
+  _qoi_evaluate_parameter_sensitivity_object   (nullptr),
   _dof_map                          (new DofMap(number_in, *this)),
   _equation_systems                 (es),
   _mesh                             (es.get_mesh()),
@@ -1838,8 +1842,57 @@ void System::attach_assemble_object (System::Assembly & assemble_in)
   _assemble_system_object = &assemble_in;
 }
 
+    
+void System::reset_assembly ()
+{
+    _assemble_system_function = NULL;
+    _assemble_system_object   = NULL;
+}
+
+
+void System::attach_sensitivity_assemble_function (bool fptr(EquationSystems& es,
+                                                                                                                           const std::string& name,
+                                                                                                                           const ParameterVector& parameters,
+                                                                                                                           const unsigned int i,
+                                                                                                                           NumericVector<Number>& sensitivity_rhs))
+{
+    libmesh_assert(fptr);
+    
+    if (_sensitivity_assemble_system_object != NULL)
+    {
+        libmesh_here();
+        libMesh::out << "WARNING:  Cannot specify both assembly sensitivity function and object!"
+        << std::endl;
+        
+        _sensitivity_assemble_system_object = NULL;
+    }
+    
+    _sensitivity_assemble_system_function = fptr;
+}
+
 
 
+void System::attach_sensitivity_assemble_object (System::SensitivityAssembly& assemble_in)
+{
+    if (_sensitivity_assemble_system_function != NULL)
+        {
+                libmesh_here();
+                libMesh::out << "WARNING:  Cannot specify both assembly object and function!"
+                << std::endl;
+                
+                _sensitivity_assemble_system_function = NULL;
+            }
+    
+    _sensitivity_assemble_system_object = &assemble_in;
+}
+
+  
+void System::reset_sensitivity_assembly ()
+{
+  _sensitivity_assemble_system_function = NULL;
+  _sensitivity_assemble_system_object   = NULL;
+}
+
 void System::attach_constraint_function(void fptr(EquationSystems & es,
                                                   const std::string & name))
 {
@@ -1859,6 +1912,15 @@ void System::attach_constraint_function(void fptr(EquationSystems & es,
 
 
 
+    
+void System::reset_QOI ()
+{
+    _qoi_evaluate_function = NULL;
+    _qoi_evaluate_object   = NULL;
+}
+    
+
+
 void System::attach_constraint_object (System::Constraint & constrain)
 {
   if (_constrain_system_function != libmesh_nullptr)
@@ -1946,6 +2008,60 @@ void System::attach_QOI_derivative_object (QOIDerivative & qoi_derivative)
 
 
 
+void System::reset_QOI_derivative ()
+{
+    _qoi_evaluate_derivative_function = NULL;
+    _qoi_evaluate_derivative_object   = NULL;
+}
+
+
+
+void System::attach_QOI_parameter_sensitivity(bool (*fptr)(libMesh::EquationSystems &,
+                                                           const std::string &,
+                                                           const libMesh::QoISet &,
+                                                           const libMesh::ParameterVector &,
+                                                           const unsigned int,
+                                                           std::vector<Number> &))
+{
+    libmesh_assert(fptr);
+    
+    if (_qoi_evaluate_parameter_sensitivity_object != NULL)
+    {
+        libmesh_here();
+        libMesh::out << "WARNING:  Cannot specify both QOI derivative function and object!"
+        << std::endl;
+        
+        _qoi_evaluate_parameter_sensitivity_object = NULL;
+    }
+    
+    _qoi_evaluate_parameter_sensitivity_function = fptr;
+}
+
+
+
+void System::attach_QOI_parameter_sensitivity_object (QOIParameterSensitivity& qoi_sensitivity)
+{
+    if (_qoi_evaluate_parameter_sensitivity_function != NULL)
+    {
+        libmesh_here();
+        libMesh::out << "WARNING:  Cannot specify both QOI derivative object and function!"
+        << std::endl;
+        
+        _qoi_evaluate_parameter_sensitivity_function = NULL;
+    }
+    
+    _qoi_evaluate_parameter_sensitivity_object = &qoi_sensitivity;
+}
+
+
+
+void System::reset_QOI_parameter_sensitivity ()
+{
+    
+    _qoi_evaluate_parameter_sensitivity_function = NULL;
+    _qoi_evaluate_parameter_sensitivity_object   = NULL;
+}
+
 void System::user_initialization ()
 {
   // Call the user-provided intialization function,
@@ -1973,6 +2089,31 @@ void System::user_assembly ()
 }
 
 
+    
+
+
+bool System::user_sensitivity_assembly (const ParameterVector& parameters,
+                                                                                 const unsigned int i,
+                                                                                 NumericVector<Number>& sensitivity_rhs)
+{
+    bool rval = false;
+
+    // Call the user-provided assembly function,
+    // if it was provided
+    if (_sensitivity_assemble_system_function != NULL)
+            rval = this->_sensitivity_assemble_system_function (_equation_systems,
+                                                                                                                             this->name(),
+                                                                                                                             parameters,
+                                                                                                                             i,
+                                                                                                                             sensitivity_rhs);
+    
+    // ...or the user-provided assembly object.
+    else if (_sensitivity_assemble_system_object != NULL)
+            rval = this->_sensitivity_assemble_system_object->sensitivity_assemble
+            (parameters, i, sensitivity_rhs);
+    
+    return rval;
+}
 
 void System::user_constrain ()
 {
@@ -2020,6 +2161,31 @@ void System::user_QOI_derivative(const QoISet & qoi_indices,
 }
 
 
+    
+bool System::user_QOI_parameter_sensitivity(const libMesh::QoISet &qoi_indices,
+                                                                                         const libMesh::ParameterVector &parameters,
+                                                                                         const unsigned int p,
+                                                                                         std::vector<Number> &partialq_partialp)
+{
+  bool rval = false;
+
+  // Call the user-provided quantity of interest derivative,
+  // if it was provided
+  if (_qoi_evaluate_parameter_sensitivity_function != NULL)
+        rval = this->_qoi_evaluate_parameter_sensitivity_function(_equation_systems,
+                                                                                                                                 this->name(),
+                                                                                                                                 qoi_indices,
+                                                                                                                                 parameters, p,
+                                                                                                                                 partialq_partialp);
+  
+  // ...or the user-provided QOI derivative function object.
+  else if (_qoi_evaluate_parameter_sensitivity_object != NULL)
+        rval = this->_qoi_evaluate_parameter_sensitivity_object->qoi_parameter_sensitivity
+        (qoi_indices, parameters, p, partialq_partialp);
+  
+  return rval;
+}
+  
 
 Number System::point_value(unsigned int var, const Point & p, const bool insist_on_success) const
 {
